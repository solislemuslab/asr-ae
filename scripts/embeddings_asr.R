# This script performs the actual ancestral state reconstruction (ASR) of embeddings
# Embeddings of tip sequences should have been generated by the Python script gen_embeddings.py and should be available for this script to read
# TODO: Fix implementation for real data

suppressPackageStartupMessages({
    library(fs) # make sure this is loaded after Biostrings to keep path() function from fs
    library(tidyverse)
    library(Rphylopars) # automatically loads ape
    library(network) # for plotting the tree as a network in embedding space
})

# get command line arguments
data_path <- commandArgs(trailingOnly = TRUE)[1]
model <- commandArgs(trailingOnly = TRUE)[2]

# name and path wrangling
if (str_detect(model, "\\.pt$")) {
    model <- str_remove(model, "\\.pt$")
}
msa_id <- path_file(data_path)
family <- str_extract(msa_id, "^[a-zA-Z0-9]+")
sim <- !str_detect(data_path, "real")
sim_type <- path_split(data_path)[[1]][2]
n_seq <- as.integer(path_file(path_dir(data_path)))
plot_dir <- if (sim) path("plots", sim_type, n_seq, msa_id) else path("plots", "real", msa_id)

## Read in family tree #####
if (sim) {
    tree_dir <- path("trees", "fast_trees", n_seq)
    tree_file <- paste0(family, ".clean.tree")
} else {
    tree_dir <- path("trees", "inferred_real_trees")
    tree_file <- paste0(family, ".treefile")
}
tree_path <- path(tree_dir, tree_file)
tree <- read.tree(tree_path)

## Read in embeddings #####
embed_dir <- path("embeddings", "data")
if (sim) {
    embed_path <- path(
        embed_dir,
        sim_type,
        n_seq,
        msa_id,
        paste0(model, "_embeddings.csv")
    )
} else {
    embed_path <- path(
        embed_dir,
        "real",
        msa_id,
        paste0(model, "_embeddings.csv")
    )
}
embeds <- read_csv(embed_path, show_col_types = FALSE) 
# check that tree labels match the labels in the embeddings dataframe
stopifnot(
    sort(str_subset(embeds$id, "^N")) == sort(tree$tip.label),
    sort(str_subset(embeds$id, "^A")) == sort(tree$node.label)
    )
embeds <- embeds |>
    mutate(vert_type = if_else(str_detect(id, "^N"), "tip", "internal"))
ntips = length(str_subset(embeds$id, "^N"))

# Check if path to ancestral embeddings exists, meaning ancestral reconstruction has already been done
anc_embed_path <- str_match(embed_path, "^(.*)embeddings.csv")[2] |>
    str_c("anc-embeddings.csv")
if (file.exists(anc_embed_path)) {
    cat("Ancestral embeddings already exists at", anc_embed_path, "\n")
    anc_exists <- TRUE
} else {
    cat("Reconstructing ancestral embeddings with brownian motion\n")
    anc_exists <- FALSE
}

## Get estimates of the ancestral embeddings by fitting BM model to tip embeddings only #####
if (!anc_exists) {
    # phylopars() requires the column of label names to be called "species" and all other columns to be numeric
    tip_embeds <- embeds |>
        dplyr::rename(species = id) |>
        filter(vert_type == "tip") |>
        select(-vert_type)
    p_BM <- phylopars(trait_data = tip_embeds, tree = tree) # brownian motion model
    anc_recon_embeds <- p_BM$anc_recon[(ntips+1):nrow(embeds),] #reconstructions of internal node embeddings based on model
    anc_recon_embeds <- as_tibble(anc_recon_embeds) |>
        mutate(id = tree$node.label) 
    write_csv(anc_recon_embeds, anc_embed_path)
} else { # read in already existing ancestral embeddings
    anc_recon_embeds <- read_csv(anc_embed_path, show_col_types = FALSE)
}

## Plot tree in embedding space #####
# First perform PCA to reduce dimensionality to 2D if there are more than 2 dimensions in embedding space
if (sum(str_detect(colnames(embeds), "dim[0-9]+")) > 2) {
    # Fit the pca to the actual embeddings, not the ancestral reconstructions
    pca <- embeds |>
        select(matches("dim[0-9]+")) |>
        prcomp()
    plotted_actual <- predict(pca)[, 1:2]
    plotted_recon <- predict(pca, newdata = anc_recon_embeds)[,1:2]
    xdim = "PC1"
    ydim = "PC2"
    xdim_recon = "PC1_recon"
    ydim_recon = "PC2_recon"
} else {
    plotted_actual <- embeds %>%
        select(matches("dim[0-9]+")) |>
        as.matrix()
    plotted_recon <- anc_recon_embeds %>%
        select(matches("dim[0-9]+")) |>
        as.matrix()
    xdim = "dim0"
    ydim = "dim1"
    xdim_recon = "dim0_recon"
    ydim_recon = "dim1_recon"
}
rownames(plotted_actual) <- embeds$id
rownames(plotted_recon) <- anc_recon_embeds$id

# Get tree as network object for plotting
net <- as.network(tree)

# make sure order of embebeddings matches the order of the vertex names in the network
if (!all(rownames(plotted_actual) == (net %v% "vertex.names"))) {
    stopifnot(nrow(plotted_actual) == length(net %v% "vertex.names"))
    plotted_actual <- plotted_actual[net %v% "vertex.names", ]
}

# Aesthetics of points
color_palette <- c(
    internal = scales::alpha("red", .4),
    tip = scales::alpha("blue", .4)
    )
vert_col <- color_palette[embeds$vert_type[match(rownames(plotted_actual), embeds$id)]]
vert_bord = NA
vert_size <- c(
    internal = .3,
    tip = .3
)[embeds$vert_type[match(rownames(plotted_actual), embeds$id)]]

png(file = path(plot_dir, paste0(model, "_network.png")), width = 1200, height = 1200)
par(mar=c(0,0,0,0)+.01)
plot.network(net,
    coord = plotted_actual,
    vertex.col = vert_col,
    vertex.border = vert_bord,
    vertex.cex = vert_size,
    edge.lwd = .3,
    edge.col = scales::alpha("black", .2),
    usearrows = FALSE,
    displaylabels = F,
    #label.cex = 1,
    # boxed.labels = T,
    # label.pos = 5,
    suppress.axes = TRUE,
)
# highlight the root, which should be the first row of the internal nodes in all_embeds
root_name <- paste0("A", as.integer(path_split(tree_dir)[[1]][3])+1)
root_index <- which(rownames(plotted_actual) == root_name)
points(plotted_actual[root_index, 1], plotted_actual[root_index, 2],
       col = "green", pch = 16, cex = 3)
legend("bottomleft",
    pch = 16,
    cex = 2,
    border = "black",
    bty = "n",
    col = color_palette,
    legend = names(color_palette),
    inset = c(.05, .05))

invisible(dev.off())

## Plot reconstructed ancestral embeddings with arrows connecting them to true ancestral embeddings ####
plotted_recon <- as_tibble(plotted_recon, rownames = "id")
plotted_all <- as_tibble(plotted_actual, rownames = "id") |>
    left_join(plotted_recon, by = "id", suffix = c("", "_recon")) |>
    left_join(select(anc_recon_embeds, -starts_with("dim")), by = "id") |>
    mutate(vert_type = if_else(str_detect(id, "^N"), "tip", "internal"))

errors_recorded = ("ham_errors" %in% colnames(plotted_all))
p <- filter(plotted_all, vert_type == "internal") |>
    ggplot(aes(
            x = .data[[xdim_recon]], 
            y = .data[[ydim_recon]])
            ) +
    #{if (errors_recorded) aes(color = ham_errors)} +
    geom_segment(aes(
        xend = .data[[xdim]], 
        yend = .data[[ydim]]),
        arrow = arrow(length = unit(0.1, "cm")), linewidth = 0.2
        ) +
    #{if (errors_recorded) scale_color_viridis_c()} +
    theme_bw() +
    labs(
        #title = paste0("Embeddings of ancestral sequences for ", msa_id, ",\n", model),
        #subtitle = "Arrow starts at estimated embeddings based on Brownian motion model\nand ends at the embedding of the actual sequence",
        color = "Hamming error",
        x = xdim,
        y = ydim
    ) +
    theme(
        legend.position = "bottom",
        plot.title = element_text(size = 8),
        plot.subtitle = element_text(size = 5)
    )
ggsave(
    paste0(model, "_internal_embedding_estimation.png"), 
    path=plot_dir,
    unit = "px",
    width = 1200,
    height = 1200
    )

# if ("ham_errors" %in% colnames(anc_recon_embeds)) {
#     colorbar_labels <- pretty(range(anc_recon_embeds$ham_errors, na.rm = TRUE), n = 5)
#     color_palette <- scales::col_numeric(
#         palette = "viridis",
#         domain = range(colorbar_labels)
#     )
#     vert_col <- if_else(str_detect(embeds$id, "^A"), color_palette(all_embeds$ham_errors), NA)
#     vert_bord <- if_else(all_embeds$vert_type == "internal", NA, "black")
# }

# if ("ham_errors" %in% colnames(all_embeds)) {
#     legend("topleft",
#         pch = 16,
#         cex = 2,
#         bty = "n",
#         col = color_palette(colorbar_labels),
#         legend = colorbar_labels,
#         title = "Ham Errors",
#         inset = c(.05, .05)
#     )
#     legend("topleft",
#         pch = 1,
#         cex = 2,
#         bty = "n",
#         col = "black",
#         legend = "Tips",
#         inset = c(.15, .08)
#     )
# } 




