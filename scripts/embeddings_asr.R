# This script performs the actual ancestral state reconstruction (ASR) of embeddings
# Embeddings of tip sequences should have been generated by the Python script gen_embeddings.py and should be available for this script to read
suppressPackageStartupMessages({
    library(fs) # make sure this is loaded after Biostrings to keep path() function from fs
    library(tidyverse)
    library(Rphylopars) # automatically loads ape
    library(network) # for plotting the tree as a network in embedding space
})

#======= Edit the following code to run the script for the desired family/model ==========#
manuscript_figure = FALSE
if (manuscript_figure) { 
    data_path = "msas/independent/processed/10000/pevae"
    model = "ding_layers500_ld2_wd0.001_epoch500_2025-07-17.pt"
} else { # family/model will be specified by command line (see `run_pipeline.sh`)
    data_path <- commandArgs(trailingOnly = TRUE)[1]
    model <- commandArgs(trailingOnly = TRUE)[2]
}
#==========================================================================================#

# name and path wrangling =================================================================#
if (str_detect(model, "\\.pt$")) {
    model <- str_remove(model, "\\.pt$")
}
msa_id <- path_file(data_path)
family <- str_extract(msa_id, "^[a-zA-Z0-9]+")
sim <- !str_detect(data_path, "real")
if (sim) {
    sim_type <- path_split(data_path)[[1]][2]
    n_seq <- as.integer(path_file(path_dir(data_path)))
}
plot_dir <- if (manuscript_figure) {
    path("figures", msa_id, model)
} else if (sim) {
    path("plots", sim_type, n_seq, msa_id)
} else {
    path("plots", "real", msa_id)
}
if (!dir.exists(plot_dir)) dir_create(plot_dir, recurse = TRUE)
# ============================================================================#

## Read in family tree #####
if (sim) {
    tree_dir <- path("trees", "fast_trees", n_seq)
    tree_file <- paste0(family, ".clean.tree")
} else if (msa_id == "PF00565_og") {
    tree_dir <- path("trees", "inferred_real_trees")
    tree_file <- paste0(family, "_rooted.treefile")
    outgroup_tip = "A0A060HE43_9ARCH/86-213"
} else {
    tree_dir <- path("trees", "inferred_real_trees")
    tree_file <- paste0(family, "_cleaned.treefile")
}
tree_path <- path(tree_dir, tree_file)
tree <- read.tree(tree_path)

## Read in embeddings #####
embed_dir <- path("embeddings", "data")
if (sim) {
    embed_path <- path(
        embed_dir,
        sim_type,
        n_seq,
        msa_id,
        paste0(model, "_embeddings.csv")
    )
} else {
    embed_path <- path(
        embed_dir,
        "real",
        msa_id,
        paste0(model, "_embeddings.csv")
    )
}
embeds <- read_csv(embed_path, show_col_types = FALSE) 
# check that tree labels match the labels in the embeddings dataframe
if (sim) {
    stopifnot(
        sort(str_subset(embeds$id, "^N")) == sort(tree$tip.label),
        sort(str_subset(embeds$id, "^A")) == sort(tree$node.label)
    )
} else if (msa_id == "PF00565_og") {
    stopifnot(
        sort(c(embeds$id, outgroup_tip)) == sort(tree$tip.label) 
    )
}

if (sim) {
    embeds <- embeds |>
        mutate(vert_type = if_else(str_detect(id, "^N"), "tip", "internal"))
    embed_leaves <- embeds %>%
        filter(vert_type == "tip")
        ntips <- nrow(embed_leaves)
        nancs <- nrow(embeds) - ntips
} else {
    embed_leaves <- embeds
    ntips <- length(tree$tip.label)
    nancs <- tree$Nnode
}


# Check if path to ancestral embeddings exists, meaning ancestral reconstruction has already been done
anc_embed_path <- str_match(embed_path, "^(.*)embeddings.csv")[2] |>
    str_c("anc-embeddings.csv")
if (file.exists(anc_embed_path)) {
    cat("Ancestral embeddings already exists at", anc_embed_path, "\n")
    anc_exists <- TRUE
} else {
    cat("Reconstructing ancestral embeddings with brownian motion\n")
    anc_exists <- FALSE
}

## Obtain reconstructed ancestral embeddings 
if (anc_exists) { # read in already existing ancestral embeddings
    recon_anc_embeds <- read_csv(anc_embed_path, show_col_types = FALSE)    
} else { # reconstructed embeddings have not yet been estimated, must estimate them with Brownian motion model fit to leaf embeddings
    # phylopars() requires the column of label names to be called "species" and all other columns to be numeric
    trait_data <- embed_leaves %>%
        dplyr::rename(species = id) %>%
        {if (sim) select(., -vert_type) else .}
    p_BM <- phylopars(trait_data = trait_data, tree = tree) # brownian motion model
    recon_anc_embeds <- p_BM$anc_recon[(ntips+1):nrow(p_BM$anc_recon),] #reconstructions of internal embeddings based on model
    recon_anc_embeds <- as_tibble(recon_anc_embeds) |>
        mutate(id = tree$node.label) 
    write_csv(recon_anc_embeds, anc_embed_path)
} 

## Note that if we are reconstruction pf00565, then our trait data dataframe does not include an embedding for the outgroup
## phylopars() will treat this as missing data and infer the embedding for this tip
## We will add this inferred embedding to recon_anc_embeds
if (msa_id == "PF00565_og") {
    recon_anc_embeds <- bind_rows(
        recon_anc_embeds,
        c(as.list(p_BM$anc_recon[rownames(p_BM$anc_recon) == outgroup_tip,]), id = outgroup_tip)
    )
}


# If we have already read in existing ancestral embeddings, then we likely also have their ASR Hamming errors recorded
errors_recorded = ("ham_errors" %in% colnames(recon_anc_embeds))

# Perform PCA to reduce dimensionality to 2D if there are more than 2 dimensions in embedding space
if (sum(str_detect(colnames(embeds), "dim[0-9]+")) > 2) {
    # Fit the pca to just the leaf embeddings
    pca <- embed_leaves |>
        select(matches("dim[0-9]+")) |>
        prcomp()
    reduced_embeds <- predict(pca, newdata = embeds)[,1:2]
    reduced_recon_anc_embeds <- predict(pca, newdata = recon_anc_embeds)[, 1:2]
    xdim = "PC1"
    ydim = "PC2"
    xdim_recon = "PC1_recon"
    ydim_recon = "PC2_recon"
} else {
    reduced_embeds <- embeds %>%
        select(matches("dim[0-9]+")) |>
        as.matrix()
    reduced_recon_anc_embeds <- recon_anc_embeds %>%
        select(matches("dim[0-9]+")) |>
        as.matrix()
    xdim = "dim0"
    ydim = "dim1"
    xdim_recon = "dim0_recon"
    ydim_recon = "dim1_recon"
}
rownames(reduced_embeds) <- embeds$id
rownames(reduced_recon_anc_embeds) <- recon_anc_embeds$id


## Plot tree in embedding space #####

# For the plotting coordinates of internal tree nodes, we will use the (reduced dimension) estimated ancestral embeddings
# To that effect, we form a matirx containing both the (reduced dimension) esimated ancestral embeddings and the leaf node embeddings
reduced_leaf_plus_recon_anc_embeds <- rbind(
    reduced_embeds[embed_leaves$id,],
    reduced_recon_anc_embeds
)

# Get tree as network object for plotting and make sure order of reduced_leaf_plus_recon_anc_embeds matches the order of the vertices in the network
net <- as.network(tree)
if (!all(rownames(reduced_leaf_plus_recon_anc_embeds) == (net %v% "vertex.names"))) {
    stopifnot(sort(rownames(reduced_leaf_plus_recon_anc_embeds)) == sort(net %v% "vertex.names"))
    reduced_leaf_plus_recon_anc_embeds <- reduced_leaf_plus_recon_anc_embeds[net %v% "vertex.names", ]
}

# Aesthetics of vertices
if (errors_recorded) {
    colorbar_labels <- pretty(range(recon_anc_embeds$ham_errors, na.rm = TRUE), n = 5)
    color_palette <- scales::col_numeric(
        palette = "viridis",
        domain = range(colorbar_labels)
    )
    vert_col <- c(
        rep(NA, ntips), 
        color_palette(recon_anc_embeds$ham_errors)
        )
    vert_bord <- c(
        rep("black", ntips),
        rep(NA, nancs)
        )
} else {
   vert_col <- c(
    rep(scales::alpha("red", .4), ntips),
    rep(scales::alpha("blue", .4), nancs)
    )
    vert_bord = rep(NA, ntips+nancs)
}

vert_size <- c(
    rep(0.3, ntips), #0.6
    rep(0.3, nancs) #0.6
)

# highlight some ancestors and leaves
# root_name <- paste0("A", as.integer(path_split(tree_dir)[[1]][3])+1)
# hlight_ancs <- c("Root", "A35368")
# hlight_ancs_index <- which(rownames(reduced_leaf_plus_recon_anc_embeds) %in% hlight_ancs)
# vert_bord[hlight_ancs_index] = "black"
# vert_size[hlight_ancs_index] = 1

# hlight_leaves <- c("A0A1I1L7I8_9GAMM/29-374", "A0A0A8E0Q6_9XANT/43-397")
# hlight_leaves_index <- which(rownames(reduced_leaf_plus_recon_anc_embeds) %in% hlight_leaves)
# vert_bord[hlight_leaves_index] = "black"
# vert_size[hlight_leaves_index] = 1


# Actual plotting
if (manuscript_figure) {
    pdf.options(family = "serif")
    pdf(file = path(plot_dir, "network.pdf"), width = 8, height = 8)
} else {
    png(file = path(plot_dir, paste0(model, "_network.png")), width = 1200, height = 1200)
}
par(mar=c(0,0,0,0)+.01)
plot.network(net,
    coord = reduced_leaf_plus_recon_anc_embeds,
    vertex.col = vert_col,
    vertex.border = vert_bord,
    vertex.cex = vert_size,
        edge.lwd = .3,
    edge.col = scales::alpha("black", .2),
    usearrows = FALSE,
    displaylabels = F,
    #label.cex = 1,
    # boxed.labels = T,
    # label.pos = 5,
    suppress.axes = TRUE,
)

# Label highlighted taxa
# text(
#     reduced_leaf_plus_recon_anc_embeds[hlight_ancs,],
#     labels = hlight_ancs,
#     adj = c(0,1.75),
#     cex = 1
# )
# text(
#     reduced_leaf_plus_recon_anc_embeds[hlight_leaves,],
#     labels = str_split_i(hlight_leaves, "/", 1),
#     adj = c(1.,0),
#     cex = 0.5
# )


# add the legend
if (errors_recorded) {
    legend("bottomleft",
        pch = 16,
        #cex = 1.65, 
        cex = 1.25,
        title.cex = 1.25,
        bty = "n",
        col = color_palette(colorbar_labels),
        legend = colorbar_labels,
        title = "ASR error\n(Hamming)",
        inset = c(0.06, 0.06),
        ncol = 2
    )
    legend("bottomleft",
        pch = 1,
        cex = 1.25, 
        #cex = .75,
        bty = "n",
        col = "black",
        legend = "Tip",
        inset = c(0.08, 0.03)
    )
} else {
    legend("bottomleft",
        pch = 16,
        cex = 1., 
        #cex = .75,
        title.cex = 1.,
        border = "black",
        bty = "n",
        col = unique(vert_col),
        legend = c("tip", "internal"),
        inset = c(0.05, 0.05)
    )
}
invisible(dev.off())

## Plot reconstructed ancestral embeddings with arrows connecting them to true ancestral embeddings ####
if (sim) {
    reduced_recon_anc_embeds <- as_tibble(reduced_recon_anc_embeds, rownames = "id")
    df_anc_embed_error <- as_tibble(reduced_embeds, rownames = "id") |>
        filter(str_detect(id, "^A")) |>
        left_join(reduced_recon_anc_embeds, by = "id", suffix = c("", "_recon")) |>
        left_join(select(recon_anc_embeds, -starts_with("dim")), by = "id") 

    set.seed(1000)
    p <- df_anc_embed_error |>
        slice_sample(n = 300) |>
        ggplot(aes(
                x = .data[[xdim_recon]], 
                y = .data[[ydim_recon]])
                ) +
        #{if (errors_recorded) aes(color = ham_errors)} +
        geom_segment(aes(
            xend = .data[[xdim]], 
            yend = .data[[ydim]]),
            arrow = arrow(length = unit(0.4, "cm")),
            #linewidth = 1
            ) +
        #{if (errors_recorded) scale_color_viridis_c()} +
        theme_minimal(base_size = 16) +
        labs(
            #title = paste0("Embeddings of ancestral sequences for ", msa_id, ",\n", model),
            #subtitle = "Arrow starts at estimated embeddings based on Brownian motion model\nand ends at the embedding of the actual sequence",
            color = "Hamming error",
            x =  expression("Z"[1]),
            y = expression("Z"[2])
        ) +
        theme(
            legend.position = "bottom",
            axis.text.x = element_blank(),
            axis.text.y = element_blank()
        ) 

    if (manuscript_figure) {
        ggsave(
            "internal_embedding_estimation.pdf", 
            path=path("figures", msa_id, model),
            width = 6,
            height = 6
            )
    }  else {
        ggsave(
            paste0(model, "_internal_embedding_estimation.png"), 
            path=plot_dir,
            unit = "px",
            width = 1200,
            height = 1200,
            bg = "white"
            )
    } 
}

