# This script performs the actual ancestral state reconstruction (ASR) of embeddings
# Embeddings of tip sequences should have been generated by the Python script gen_embeddings.py and should be available for this script to read
# TODO: Fix implementation for real data

suppressPackageStartupMessages({
    library(fs) # make sure this is loaded after Biostrings to keep path() function from fs
    library(tidyverse)
    library(Rphylopars) # automatically loads ape
    library(network) # for plotting the tree as a network in embedding space
})

# get command line arguments
data_path <- commandArgs(trailingOnly = TRUE)[1]
model <- commandArgs(trailingOnly = TRUE)[2]

# name and path wrangling
if (str_detect(model, "\\.pt$")) {
    model <- str_remove(model, "\\.pt$")
}
msa_id <- path_file(data_path)
family <- str_extract(msa_id, "^[a-zA-Z0-9]+")
sim <- str_detect(msa_id, "COG")
sim_type <- path_split(data_path)[[1]][2]
n_seq <- as.integer(path_file(path_dir(data_path)))
plot_dir <- if (sim) path("plots", sim_type, n_seq, msa_id) else path("plots", "real", msa_id)

## Read in family tree #####
if (sim) {
    tree_dir <- path("trees", "fast_trees", n_seq)
    tree_file <- paste0(family, ".clean.tree")
} else {
    tree_dir <- path("trees", "inferred_real_trees")
    tree_file <- paste0(family, ".treefile")
}
tree_path <- path(tree_dir, tree_file)
tree <- read.tree(tree_path)

## Read in embeddings #####
embed_dir <- path("embeddings", "data")
if (sim) {
    embed_path <- path(
        embed_dir,
        sim_type,
        n_seq,
        msa_id,
        paste0(model, "_embeddings.csv")
    )
} else {
    embed_path <- path(
        embed_dir,
        "real",
        msa_id,
        paste0(model, "_embeddings.csv")
    )
}
embeds <- read_csv(embed_path, show_col_types = FALSE)
# check that tree tip labels match the species in the embeddings
stopifnot(
    sort(embeds$id) == sort(tree$tip.label)
    )
ntips = nrow(embeds)

## Check if path to ancestral embeddings exists, meaning ancestral reconstruction has already been done
anc_embed_path <- str_match(embed_path, "^(.*)embeddings.csv")[2] |>
    str_c("anc-embeddings.csv")
if (file.exists(anc_embed_path)) {
    cat("Ancestral embeddings already exists at", anc_embed_path, "\n")
    anc_exists <- TRUE
} else {
    cat("Reconstructing ancestral embeddings with brownian motion\n")
    anc_exists <- FALSE
}

## Reconstruct the ancestral embeddings #####
if (!anc_exists) {
    # phylopars() requires the column of label names to be called "species"
    embeds <- embeds |>
        dplyr::rename(species = id)
    ## Perform ancestral state reconstruction with Brownian motion model
    p_BM <- phylopars(trait_data = embeds, tree = tree)
    #Data frame with embeddings of tips and reconstructions of internal node embeddings based on model
    all_embeds <- p_BM$anc_recon
    # Tips appear first, followed by the internal nodes (and the ordering of internal nodes should be the same as tree$node.label)
    rownames(all_embeds)[(ntips + 1):nrow(all_embeds)] <- tree$node.label
    # Turn into tibble
    all_embeds <- all_embeds |>
        as_tibble(rownames = "id") |>
        mutate(vert_type = ifelse(id %in% tree$node.label, "internal", "tip"))
    # save reconstructed ancestral embeddings
    anc_embeds <- all_embeds |>
        filter(vert_type == "internal")
    anc_embeds |> select(-vert_type) |>
        write_csv(anc_embed_path)
} else { # read in already existing ancestral embeddings
    anc_embeds <- read_csv(anc_embed_path, show_col_types = FALSE)
    all_embeds <- bind_rows(list(
        tip = embeds,
        internal = anc_embeds
    ), .id = "vert_type")
}

## Plot tree in embedding space #####
# Perform PCA to reduce dimensionality to 2D if there are more than 2 dimensions in embedding space
if (sum(str_detect(colnames(all_embeds), "dim")) > 2) {
    pca <- all_embeds |>
        filter(vert_type == "tip") |>
        select(starts_with("dim")) |>
        prcomp()
    plotted_coords <- predict(pca, all_embeds)[, 1:2]
} else {
    plotted_coords <- all_embeds %>%
        select(starts_with("dim")) |>
        as.matrix()
}

# Aesthetics of points
if ("ham_errors" %in% colnames(all_embeds)) {
    colorbar_labels <- pretty(range(all_embeds$ham_errors, na.rm = TRUE), n = 5)
    color_palette <- scales::col_numeric(
        palette = "viridis",
        domain = range(colorbar_labels)
    )
    vert_col <- if_else(all_embeds$vert_type == "internal", color_palette(all_embeds$ham_errors), NA)
    vert_bord <- if_else(all_embeds$vert_type == "internal", NA, "black")
} else {
   color_palette <- c(
    internal = scales::alpha("blue", .4),
    tip = scales::alpha("red", .4)
    )
    vert_col <- color_palette[all_embeds$vert_type]
    vert_bord = NA
}

vert_size <- c(
    internal = .3,
    tip = .3
)[all_embeds$vert_type]

# Plot whole tree
net <- as.network(tree)
stopifnot( # check that correct order is preserved
  all(all_embeds$id == (net %v% "vertex.names"))
)
png(file = path(plot_dir, paste0(model, "_network.png")), width = 1200, height = 1200)
par(mar=c(0,0,0,0)+.01)
plot.network(net,
    coord = plotted_coords,
    vertex.col = vert_col,
    vertex.border = vert_bord,
    vertex.cex = vert_size,
    edge.lwd = .3,
    edge.col = scales::alpha("black", .2),
    usearrows = FALSE,
    displaylabels = F,
    #label.cex = 1,
    # boxed.labels = T,
    # label.pos = 5,
    suppress.axes = TRUE,
)
# highlight the root, which should be the first row of the internal nodes in all_embeds
#root_index <- ntips + 1
# points(plotted_coords[root_index, 1], plotted_coords[root_index, 2],
#        col = "green", pch = 16, cex = 1)

# Add legend
if ("ham_errors" %in% colnames(all_embeds)) {
    legend("topleft",
        pch = 16,
        cex = 2,
        bty = "n",
        col = color_palette(colorbar_labels),
        legend = colorbar_labels,
        title = "Ham Errors",
        inset = c(.05, .05)
    )
    legend("topleft",
        pch = 1,
        cex = 2,
        bty = "n",
        col = "black",
        legend = "Tips",
        inset = c(.15, .08)
    )
} else {
    legend("bottomleft",
        pch = 16,
        cex = 2,
        border = "black",
        bty = "n",
        col = color_palette,
        legend = names(color_palette),
        inset = c(.05, .05)
    )
}
invisible(dev.off())




